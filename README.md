# athena
gin和grpc项目脚手架，用于学习golang

## 目录结构

``` txt
├── application                  # 应用层
│ ├── event                      # 事件
│ │ ├── publish                  # 事件发布相关代码 事件处理相关的核心业务逻辑在领域层实现
│ │ ├── subscribe                # 事件订阅相关代码 事件处理相关的核心业务逻辑在领域层实现
│ │ └── init.go                  # 初始化事件
│ └── service                    # 应用服务。
├── cmd                          # 服务运行
│   └── server                   # 服务
│      └── main.go               # 主函数
├── domain                       # 领域层
│ └── aggregate1                 # 聚合
│  ├── entity                    # 实体
│  ├── repository                # 仓储
│  └── service                   # 领域服务层
├── infrastructure               # 基础设施
│   ├── config                   # 配置文件
│   ├── proto                    # pb文件
│   └── util                     # 工具
└── internal                     # Makefile
    ├── grpc                     # grpc相关
    ├── http                     # http相关
    ├── test                     # grpc 自动化测试相关
```

### 目录结构
本项目结构分层基于DDD
### DDD是什么

> DDD是一种设计思想，它本身不绑定到任何一种具体的架构风格，可以应用在多种不同的架构风格中。

### 用户接口层（internal）

提供较粗粒度的调用接口，将用户请求委派给一个或多个应用服务进行处理。

### 应用层（application）

Application 的代码目录结构有：event 和 service。

**Event（事件）**：这层目录主要存放事件相关的代码。它包括两个子目录：publish 和subscribe。前者主要存放事件发布相关代码，后者主要存放事件订阅相关代码（事件处理相关的核心业务逻辑在领域层实现）。
虽然应用层和领域层都可以进行事件的发布和处理，但为了实现事件的统一管理，建议将微服务内所有事件的发布和订阅的处理都统一放到应用层，事件相关的核心业务逻辑实现放在领域层。通过应用层调用领域层服务，来实现完整的事件发布和订阅处理流程。

**Service（应用服务）**：这层的服务是应用服务。应用服务会对多个领域服务或外部应用服务进行封装、编排和组合，对外提供粗粒度的服务。应用服务主要实现服务组合和编排，是一段独立的业务逻辑。可以将所有应用服务放在一个应用服务类里，也可以把一个应用服务设计为一个应用服务类，以防应用服务类代码量过大。

### 领域层（domain）

**Aggregate（聚合）**：它是聚合软件包的根目录，可以根据实际项目的聚合名称命名，比如权限聚合。在聚合内定义聚合根、实体和值对象以及领域服务之间的关系和边界。聚合内实现高内聚的业务逻辑，它的代码可以独立拆分为微服务。以聚合为单位的代码放在一个包里的主要目的是为了业务内聚，而更大的目的是为了以后微服务之间聚合的重组。聚合之间清晰的代码边界，可以让你轻松地实现以聚合为单位的微服务重组，在微服务架构演进中有着很重要的作用。
**Entity（实体）**：它存放聚合根、实体、值对象以及工厂模式（Factory）相关代码。实体类采用充血模型，同一实体相关的业务逻辑都在实体类代码中实现。跨实体的业务逻辑代码在领域服务中实现。
**Service（领域服务）**：它存放领域服务代码。一个领域服务是多个实体组合出来的一段业务逻辑。你可以将聚合内所有领域服务都放在一个领域服务类中，你也可以把每一个领域服务设计为一个类。如果领域服务内的业务逻辑相对复杂，我建议你将一个领域服务设计为一个领域服务类，避免由于所有领域服务代码都放在一个领域服务类中，而出现代码臃肿的问题。领域服务封装多个实体或方法后向上层提供应用服务调用。
**Repository（仓储）**：它存放所在聚合的查询或持久化领域对象的代码，通常包括仓储接口和仓储实现方法。为了方便聚合的拆分和组合，我们设定了一个原则：一个聚合对应一个仓储。

特别说明：按照 DDD 分层架构，仓储实现本应该属于基础层代码，但为了在微服务架构演进时，保证代码拆分和重组的便利性，我是把聚合仓储实现的代码放到了聚合包内。这样，如果需求或者设计发生变化导致聚合需要拆分或重组时，我们就可以将包括核心业务逻辑和仓储代码的聚合包整体迁移，轻松实现微服务架构演进。

### 基础层（infrastructure）

Infrastructure 的代码目录结构有：config 和 util 两个子目录
**Config**：主要存放配置相关代码。
**Util**：主要存放平台、开发框架、消息、数据库、缓存、文件、总线、网关、第三方类库、通用算法等基础代码，可以为不同的资源类别建立不同的子目录